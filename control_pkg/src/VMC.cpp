#include "controller.h"

void VMC::leg_pos(Leg_Model *leg) // 计算 左腿 姿态，得到实际腿长L0和足端角度phi0，输入为国际标准单位
{
    double t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t23, t24, t25,
        t26, t27, t28, t29, t30, t31, t32, t34, t35, t36, t37, t38, t39; // t33,t22
    t2 = cos(leg->phi1);
    t3 = cos(leg->phi4);
    t4 = sin(leg->phi1);
    t5 = sin(leg->phi4);
    t6 = pow(L2, 2);
    t7 = pow(L3, 2);
    t12 = L5 / 2.0;
    t8 = L1 * t2;
    t9 = L4 * t3;
    t10 = L1 * t4;
    t11 = L4 * t5;
    t13 = -t7;
    t16 = -t12;
    t14 = -t8;
    t15 = -t11;
    t17 = t10 + t15;
    t18 = L5 + t9 + t14;
    t19 = pow(t17, 2);
    t20 = pow(t18, 2);
    t21 = L2 * t17 * 2.0;
    t23 = L2 * t18 * 2.0;
    // t22 = -t21;
    t24 = t6 * t19 * 4.0;
    t25 = t6 * t20 * 4.0;
    t26 = t6 + t13 + t19 + t20;
    t27 = pow(t26, 2);
    t29 = t23 + t26;
    t28 = -t27;
    t30 = 1.0 / t29;
    t31 = t24 + t25 + t28;
    t32 = sqrt(t31);
    // t33 = t22 + t32;
    t34 = -t30 * (t21 - t32);
    t35 = atan(t34);
    t36 = t35 * 2.0;
    t37 = cos(t36);
    t38 = sin(t36);
    t39 = L2 * t37;
    leg->L0 = sqrt(pow((t8 + t16 + t39), 2) + pow((t10 + L2 * t38), 2));
    leg->phi0 = atan2(t10 + L2 * t38, t8 + t16 + t39);
    leg->theta = (leg->phi0 - 0.5 * pi - leg->phi);
}

void VMC::leg_spd(Leg_Model *leg) // 计算 左腿 运动速度dL0，dphi0，输入为国际标准单位
{
    double t10_tmp;
    double t12_tmp;
    double t2;
    double t21;
    double t22;
    double t23;
    double t24;
    double t28;
    double t3;
    double t30;
    double t31;
    double t38;
    double t4;
    double t44;
    double t47;
    double t48;
    double t5;
    double t52;
    double t53;
    double t60;
    double t70;
    double t76;
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     01-Feb-2024 11:26:13
    t2 = std::cos(leg->phi1);
    t3 = std::cos(leg->phi4);
    t4 = std::sin(leg->phi1);
    t5 = std::sin(leg->phi4);
    t10_tmp = t2 * 0.139;
    t12_tmp = t4 * 0.139;
    t21 = t2 * 0.066442;
    t22 = t3 * 0.066442;
    t23 = t4 * 0.066442;
    t24 = t5 * 0.066442;
    t28 = t12_tmp - t5 * 0.139;
    t30 = (t3 * 0.139 - t10_tmp) + 0.117;
    t31 = t23 - t24;
    t38 = (t22 - t21) + 0.055926;
    t44 = t28 * t28 + t30 * t30;
    t47 = t2 * t28 * 0.278 + t4 * t30 * 0.278;
    t48 = t3 * t28 * 0.278 + t5 * t30 * 0.278;
    t52 = 1.0 / (t38 + t44);
    t53 = t52 * t52;
    t28 = std::sqrt((t31 * t31 + t38 * t38) - t44 * t44);
    t60 = 1.0 / t28;
    t30 = (t24 - t23) + t28;
    t28 = std::atan(t52 * t30) * 2.0;
    t70 = std::cos(t28);
    t28 = std::sin(t28);
    t76 = 1.0 / (t53 * (t30 * t30) + 1.0);
    t47 = (t23 + t47) * t53 * t30 +
          t52 * (t21 - t60 *
                           ((t2 * t31 * 0.132884 + t4 * t38 * 0.132884) -
                            t44 * t47 * 2.0) /
                           2.0);
    t30 = (t24 + t48) * t53 * t30 +
          t52 * (t22 - t60 *
                           ((t3 * t31 * 0.132884 + t5 * t38 * 0.132884) -
                            t44 * t48 * 2.0) /
                           2.0);
    t4 = t12_tmp + t28 * 0.239;
    t21 = (t10_tmp + t70 * 0.239) - 0.0585;
    t60 = t70 * t76;
    t23 = t60 * t30;
    t28 *= t76;
    t2 = t28 * t30;
    t30 = (-t10_tmp - t70 * 0.239) + 0.0585;
    t53 = t30 * t30;
    t48 = 1.0 / t30;
    t30 = 1.0 / std::sqrt(t4 * t4 + t21 * t21);
    t52 = 1.0 / (t4 * t4 + t53);
    t60 = t10_tmp - t60 * t47 * 0.478;
    t28 = t12_tmp - t28 * t47 * 0.478;
    leg->dL0->update(leg->dphi4 * t30 * (t4 * t23 * 0.956 - t21 * t2 * 0.956) / 2.0 +
                     leg->dphi1 * t30 * (t4 * t60 * 2.0 - t21 * t28 * 2.0) / 2.0);
    t30 = t4 * (1.0 / t53);
    leg->dphi0 =
        leg->dphi4 * t53 * t52 * (t48 * (0.0 - t23 * 0.478) + t30 * (t2 * 0.478)) -
        leg->dphi1 * t53 * t52 * (t48 * t60 - t30 * t28);
    leg->dtheta = leg->dphi0 - leg->dphi;
    leg->dTheta->update(leg->dtheta);
}

void VMC::leg_conv(Leg_Model *leg) // 求 左腿 的VMC转换矩阵
{
    double a_tmp;
    double t104;
    double t120_tmp;
    double t123_tmp;
    double t124_tmp;
    double t131;
    double t143;
    double t148;
    double t16_tmp;
    double t175;
    double t180;
    double t181;
    double t182;
    double t18_tmp;
    double t33_tmp;
    double t34_tmp;
    double t35_tmp;
    double t36_tmp;
    double t52_tmp;
    double t5_tmp;
    double t64_tmp;
    double t6_tmp;
    double t75;
    double t79;
    double t7_tmp;
    double t81;
    double t82;
    double t83;
    double t84;
    double t90;
    double t91;
    double t93;
    double t94;
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     01-Feb-2024 11:26:15
    t182 = std::cos(leg->phi1);
    t5_tmp = std::cos(leg->phi4);
    t6_tmp = std::sin(leg->phi1);
    t7_tmp = std::sin(leg->phi4);
    t16_tmp = t182 * 0.139;
    t18_tmp = t6_tmp * 0.139;
    t33_tmp = t182 * 0.066442;
    t34_tmp = t5_tmp * 0.066442;
    t35_tmp = t6_tmp * 0.066442;
    t36_tmp = t7_tmp * 0.066442;
    t104 = t18_tmp - t7_tmp * 0.139;
    t90 = (t5_tmp * 0.139 - t16_tmp) + 0.117;
    t52_tmp = t35_tmp - t36_tmp;
    t64_tmp = (t34_tmp - t33_tmp) + 0.055926;
    t75 = t104 * t104 + t90 * t90;
    t81 = t182 * t104 * 0.278 + t6_tmp * t90 * 0.278;
    t82 = t5_tmp * t104 * 0.278 + t7_tmp * t90 * 0.278;
    t79 = t104 * t104 + t90 * t90;
    t83 = t182 * t104 * 0.278 + t6_tmp * t90 * 0.278;
    t84 = t5_tmp * t104 * 0.278 + t7_tmp * t90 * 0.278;
    t90 = 1.0 / (t64_tmp + t75);
    t91 = t90 * t90;
    t93 = 1.0 / (t64_tmp + t79);
    t94 = t93 * t93;
    t104 = std::sqrt((t52_tmp * t52_tmp + t64_tmp * t64_tmp) - t75 * t75);
    t148 = 1.0 / t104;
    t175 = (t36_tmp - t35_tmp) + t104;
    t120_tmp = std::atan(t90 * t175) * 2.0;
    t123_tmp = std::cos(t120_tmp);
    t124_tmp = std::sin(t120_tmp);
    t131 = 1.0 / (t91 * (t175 * t175) + 1.0);
    t143 = 1.0 / (t94 * (t175 * t175) + 1.0);
    t180 = (t35_tmp + t81) * t91 * t175 +
           t90 * (t33_tmp -
                  t148 *
                      ((t182 * t52_tmp * 0.132884 + t6_tmp * t64_tmp * 0.132884) -
                       t75 * t81 * 2.0) /
                      2.0);
    t181 =
        (t36_tmp + t82) * t91 * t175 +
        t90 * (t34_tmp -
               t148 *
                   ((t5_tmp * t52_tmp * 0.132884 + t7_tmp * t64_tmp * 0.132884) -
                    t75 * t82 * 2.0) /
                   2.0);
    a_tmp = t18_tmp + t124_tmp * 0.239;
    t120_tmp = (t16_tmp + t123_tmp * 0.239) - 0.0585;
    t182 = (t35_tmp + t83) * t94 * t175 +
           t93 * (t33_tmp -
                  t148 *
                      ((t182 * t52_tmp * 0.132884 + t6_tmp * t64_tmp * 0.132884) -
                       t79 * t83 * 2.0) /
                      2.0);
    t93 =
        (t36_tmp + t84) * t94 * t175 +
        t93 * (t34_tmp -
               t148 *
                   ((t5_tmp * t52_tmp * 0.132884 + t7_tmp * t64_tmp * 0.132884) -
                    t79 * t84 * 2.0) /
                   2.0);
    t94 = t18_tmp + t124_tmp * 0.239;
    t148 = (t16_tmp + t123_tmp * 0.239) - 0.0585;
    t104 = (-t16_tmp - t123_tmp * 0.239) + 0.0585;
    t82 = t104 * t104;
    t175 = 1.0 / t104;
    t84 = t123_tmp * t143;
    t75 = t124_tmp * t143;
    t81 = leg->F * (1.0 / std::sqrt(a_tmp * a_tmp + t120_tmp * t120_tmp));
    t91 = t123_tmp * t131;
    t90 = t124_tmp * t131;
    t120_tmp = a_tmp * (1.0 / t82);
    t104 = leg->Tp * t82 * (1.0 / (a_tmp * a_tmp + t82));
    leg->T1 = t81 *
                  (t94 * (t16_tmp - t84 * t182 * 0.478) * 2.0 -
                   t148 * (t18_tmp - t75 * t182 * 0.478) * 2.0) /
                  2.0 -
              t104 * (t175 * (t16_tmp - t91 * t180 * 0.478) -
                      t120_tmp * (t18_tmp - t90 * t180 * 0.478));
    leg->T2 = t81 * (t84 * t94 * t93 * 0.956 - t75 * t148 * t93 * 0.956) / 2.0 +
              t104 * (t175 * (0.0 - t91 * t181 * 0.478) +
                      t120_tmp * (t90 * t181 * 0.478));
}

void VMC::FN_solve(Leg_Model *leg)
{
    double P = 0;
    double cos_theta = 0;
    double sin_theta = 0;
    double F = 0;
    double Tp = 0;
    double L0 = 0;
    double dL0 = 0;
    double ddL0 = 0;
    double theta = 0;
    double dtheta = 0;
    double ddtheta = 0;
    double ddzw = 0;
    double ddzm = 0;
    double r, p;
    r = roll * pi / 180;
    p = pitch * pi / 180;
    theta = leg->theta;
    dtheta = leg->dTheta->now;
    ddtheta = leg->dTheta->d;
    F = leg->F;
    Tp = leg->Tp;
    L0 = leg->L0;
    dL0 = leg->dL0->now;
    ddL0 = leg->dL0->d;
    cos_theta = std::cos(theta);
    sin_theta = std::sin(theta);
    ddzm = -ddx * sin(p) + ddy * cos(p) * sin(r) + ddz * cos(r) * cos(p) - g;
    ddzw = ddzm - ddL0 * cos_theta + 2 * dL0 * dtheta * sin_theta + L0 * ddtheta * sin_theta + L0 * dtheta * dtheta * cos_theta;
    P = F * cos_theta + Tp * sin_theta / L0;
    leg->FN = P + m_wheel * g + m_wheel * ddzw;
    // cout << "F=" << F << ",FN=" << leg->FN << endl;
    if (leg->FN <= off_ground_F) // 支持力不够
    {
        if (!leg->isRobotOffGround) // 当前为落地状态
        {
            leg->counter_OffGround++;
        }
        else // 当前为离地状态
        {
            leg->counter_OffGround = 0;
        }
    }
    else // 支持力够
    {
        if (!leg->isRobotOffGround) // 当前为落地状态
        {
            leg->counter_OffGround = 0;
        }
        else // 当前为离地状态
        {
            leg->counter_OffGround--;
        }
    }
    if (leg->counter_OffGround > 3)
    {
        leg->isRobotOffGround = true;
        ROS_ERROR("robotoffground");
    }
    if (leg->counter_OffGround < -3)
    {
        leg->isRobotOffGround = false;
    }
}

void VMC::leg_conv_comb(Leg_Model *leg) // double Fx, double Fz, double phi1, double phi4, double T[2]
{
    double t12;
    double t13;
    double t14;
    double t15;
    double t19;
    double t2;
    double t21;
    double t25;
    double t29;
    double t3;
    double t33;
    double t38;
    double t39;
    double t4;
    double t43;
    double t44;
    double t5;
    double t51;
    double t52;
    double t6;
    double t61;
    double t62;
    double t63;
    double t8;
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     17-Sep-2024 20:25:43
    t2 = std::cos(leg->phi1);
    t3 = std::cos(leg->phi4);
    t4 = std::sin(leg->phi1);
    t5 = std::sin(leg->phi4);
    t6 = t2 * 0.141;
    t8 = t4 * 0.141;
    t12 = t2 * 0.070077;
    t13 = t3 * 0.070077;
    t14 = t4 * 0.070077;
    t15 = t5 * 0.070077;
    t19 = t8 - t5 * 0.141;
    t21 = (t3 * 0.141 - t6) + 0.12;
    t25 = t14 - t15;
    t29 = (t13 - t12) + 0.05964;
    t33 = t19 * t19 + t21 * t21;
    t38 = t2 * t19 * 0.282 + t4 * t21 * 0.282;
    t39 = t3 * t19 * 0.282 + t5 * t21 * 0.282;
    t43 = 1.0 / (t29 + t33);
    t44 = t43 * t43;
    t19 = std::sqrt((t25 * t25 + t29 * t29) - t33 * t33);
    t51 = 1.0 / t19;
    t52 = (t15 - t14) + t19;
    t19 = std::atan(t43 * t52) * 2.0;
    t61 = std::cos(t19);
    t62 = std::sin(t19);
    t63 = 1.0 / (t44 * (t52 * t52) + 1.0);
    t21 = (t14 + t38) * t44 * t52 +
          t43 * (t12 - t51 *
                           ((t2 * t25 * 0.140154 + t4 * t29 * 0.140154) -
                            t33 * t38 * 2.0) /
                           2.0);
    t19 = (t15 + t39) * t44 * t52 +
          t43 * (t13 - t51 *
                           ((t3 * t25 * 0.140154 + t5 * t29 * 0.140154) -
                            t33 * t39 * 2.0) /
                           2.0);
    // 单腿后侧电机的扭矩
    leg->T2 = -leg->Fx * (t8 - t62 * t63 * t21 * 0.497) +
           leg->Fz * (t6 - t61 * t63 * t21 * 0.497);
    leg->T2 *= (-1);
    // 单腿前侧电机的扭矩
    leg->T1 = leg->Fx * t62 * t63 * t19 * -0.497 + leg->Fz * t61 * t63 * t19 * 0.497;
    leg->T1 *= (-1);
}
