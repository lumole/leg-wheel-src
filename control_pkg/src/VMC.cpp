#include "controller.h"

void VMC::leg_pos(Leg_Model *leg) // 计算 左腿 姿态，得到实际腿长L0和足端角度phi0，输入为国际标准单位
{
    double t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t23, t24, t25,
        t26, t27, t28, t29, t30, t31, t32, t34, t35, t36, t37, t38, t39; // t33,t22
    t2 = cos(leg->phi1);
    t3 = cos(leg->phi4);
    t4 = sin(leg->phi1);
    t5 = sin(leg->phi4);
    t6 = pow(L2, 2);
    t7 = pow(L3, 2);
    t12 = L5 / 2.0;
    t8 = L1 * t2;
    t9 = L4 * t3;
    t10 = L1 * t4;
    t11 = L4 * t5;
    t13 = -t7;
    t16 = -t12;
    t14 = -t8;
    t15 = -t11;
    t17 = t10 + t15;
    t18 = L5 + t9 + t14;
    t19 = pow(t17, 2);
    t20 = pow(t18, 2);
    t21 = L2 * t17 * 2.0;
    t23 = L2 * t18 * 2.0;
    // t22 = -t21;
    t24 = t6 * t19 * 4.0;
    t25 = t6 * t20 * 4.0;
    t26 = t6 + t13 + t19 + t20;
    t27 = pow(t26, 2);
    t29 = t23 + t26;
    t28 = -t27;
    t30 = 1.0 / t29;
    t31 = t24 + t25 + t28;
    t32 = sqrt(t31);
    // t33 = t22 + t32;
    t34 = -t30 * (t21 - t32);
    t35 = atan(t34);
    t36 = t35 * 2.0;
    t37 = cos(t36);
    t38 = sin(t36);
    t39 = L2 * t37;
    leg->L0 = sqrt(pow((t8 + t16 + t39), 2) + pow((t10 + L2 * t38), 2));
    leg->phi0 = atan2(t10 + L2 * t38, t8 + t16 + t39);
    leg->theta = (leg->phi0 - 0.5 * pi - leg->phi);
}

void VMC::leg_spd(Leg_Model *leg) // 计算 左腿 运动速度dL0，dphi0，输入为国际标准单位
{
    double t10_tmp;
    double t12_tmp;
    double t2;
    double t21;
    double t22;
    double t23;
    double t24;
    double t28;
    double t3;
    double t30;
    double t34;
    double t38;
    double t4;
    double t42;
    double t47;
    double t48;
    double t5;
    double t52;
    double t53;
    double t60;
    double t70;
    double t76;
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     23-Jul-2024 10:45:31
    t2 = std::cos(leg->phi1);
    t3 = std::cos(leg->phi4);
    t4 = std::sin(leg->phi1);
    t5 = std::sin(leg->phi4);
    t10_tmp = t2 * 0.141;
    t12_tmp = t4 * 0.141;
    t21 = t2 * 0.070077;
    t22 = t3 * 0.070077;
    t23 = t4 * 0.070077;
    t24 = t5 * 0.070077;
    t28 = t12_tmp - t5 * 0.141;
    t30 = (t3 * 0.141 - t10_tmp) + 0.12;
    t34 = t23 - t24;
    t38 = (t22 - t21) + 0.05964;
    t42 = t28 * t28 + t30 * t30;
    t47 = t2 * t28 * 0.282 + t4 * t30 * 0.282;
    t48 = t3 * t28 * 0.282 + t5 * t30 * 0.282;
    t52 = 1.0 / (t38 + t42);
    t53 = t52 * t52;
    t28 = std::sqrt((t34 * t34 + t38 * t38) - t42 * t42);
    t60 = 1.0 / t28;
    t30 = (t24 - t23) + t28;
    t28 = std::atan(t52 * t30) * 2.0;
    t70 = std::cos(t28);
    t28 = std::sin(t28);
    t76 = 1.0 / (t53 * (t30 * t30) + 1.0);
    t47 = (t23 + t47) * t53 * t30 +
          t52 * (t21 - t60 *
                           ((t2 * t34 * 0.140154 + t4 * t38 * 0.140154) -
                            t42 * t47 * 2.0) /
                           2.0);
    t30 = (t24 + t48) * t53 * t30 +
          t52 * (t22 - t60 *
                           ((t3 * t34 * 0.140154 + t5 * t38 * 0.140154) -
                            t42 * t48 * 2.0) /
                           2.0);
    t4 = t12_tmp + t28 * 0.2485;
    t21 = (t10_tmp + t70 * 0.2485) - 0.06;
    t60 = t70 * t76;
    t23 = t60 * t30;
    t28 *= t76;
    t2 = t28 * t30;
    t30 = (-t10_tmp - t70 * 0.2485) + 0.06;
    t53 = t30 * t30;
    t48 = 1.0 / t30;
    t30 = 1.0 / std::sqrt(t4 * t4 + t21 * t21);
    t52 = 1.0 / (t4 * t4 + t53);
    t60 = t10_tmp - t60 * t47 * 0.497;
    t28 = t12_tmp - t28 * t47 * 0.497;
    // spd[0] = dphi4 * t30 * (t4 * t23 * 0.994 - t21 * t2 * 0.994) / 2.0 +
    //          dphi1 * t30 * (t4 * t60 * 2.0 - t21 * t28 * 2.0) / 2.0;
    // t30 = t4 * (1.0 / t53);
    // spd[1] =
    //     dphi4 * t53 * t52 * (t48 * (0.0 - t23 * 0.497) + t30 * (t2 * 0.497)) -
    //     dphi1 * t53 * t52 * (t48 * t60 - t30 * t28);

    leg->dL0->update(leg->dphi4 * t30 * (t4 * t23 * 0.994 - t21 * t2 * 0.994) / 2.0 +
                     leg->dphi1 * t30 * (t4 * t60 * 2.0 - t21 * t28 * 2.0) / 2.0);
    t30 = t4 * (1.0 / t53);
    leg->dphi0 =
        leg->dphi4 * t53 * t52 * (t48 * (0.0 - t23 * 0.497) + t30 * (t2 * 0.497)) -
        leg->dphi1 * t53 * t52 * (t48 * t60 - t30 * t28);
    leg->dtheta = leg->dphi0 - leg->dphi;
    leg->dTheta->update(leg->dtheta);
}

void VMC::leg_conv(Leg_Model *leg) // 求 左腿 的VMC转换矩阵
{
    double a_tmp;
    double t104;
    double t120_tmp;
    double t123_tmp;
    double t124_tmp;
    double t131;
    double t143;
    double t148;
    double t16_tmp;
    double t175;
    double t180;
    double t181;
    double t182;
    double t18_tmp;
    double t33_tmp;
    double t34_tmp;
    double t35_tmp;
    double t36_tmp;
    double t57_tmp;
    double t5_tmp;
    double t66_tmp;
    double t6_tmp;
    double t73;
    double t75;
    double t7_tmp;
    double t81;
    double t82;
    double t83;
    double t84;
    double t90;
    double t91;
    double t93;
    double t94;
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     23-Jul-2024 10:45:35
    t182 = std::cos(leg->phi1);
    t5_tmp = std::cos(leg->phi4);
    t6_tmp = std::sin(leg->phi1);
    t7_tmp = std::sin(leg->phi4);
    t16_tmp = t182 * 0.141;
    t18_tmp = t6_tmp * 0.141;
    t33_tmp = t182 * 0.070077;
    t34_tmp = t5_tmp * 0.070077;
    t35_tmp = t6_tmp * 0.070077;
    t36_tmp = t7_tmp * 0.070077;
    t104 = t18_tmp - t7_tmp * 0.141;
    t90 = (t5_tmp * 0.141 - t16_tmp) + 0.12;
    t57_tmp = t35_tmp - t36_tmp;
    t66_tmp = (t34_tmp - t33_tmp) + 0.05964;
    t73 = t104 * t104 + t90 * t90;
    t81 = t182 * t104 * 0.282 + t6_tmp * t90 * 0.282;
    t82 = t5_tmp * t104 * 0.282 + t7_tmp * t90 * 0.282;
    t75 = t104 * t104 + t90 * t90;
    t83 = t182 * t104 * 0.282 + t6_tmp * t90 * 0.282;
    t84 = t5_tmp * t104 * 0.282 + t7_tmp * t90 * 0.282;
    t90 = 1.0 / (t66_tmp + t73);
    t91 = t90 * t90;
    t93 = 1.0 / (t66_tmp + t75);
    t94 = t93 * t93;
    t104 = std::sqrt((t57_tmp * t57_tmp + t66_tmp * t66_tmp) - t73 * t73);
    t148 = 1.0 / t104;
    t175 = (t36_tmp - t35_tmp) + t104;
    t120_tmp = std::atan(t90 * t175) * 2.0;
    t123_tmp = std::cos(t120_tmp);
    t124_tmp = std::sin(t120_tmp);
    t131 = 1.0 / (t91 * (t175 * t175) + 1.0);
    t143 = 1.0 / (t94 * (t175 * t175) + 1.0);
    t180 = (t35_tmp + t81) * t91 * t175 +
           t90 * (t33_tmp -
                  t148 *
                      ((t182 * t57_tmp * 0.140154 + t6_tmp * t66_tmp * 0.140154) -
                       t73 * t81 * 2.0) /
                      2.0);
    t181 =
        (t36_tmp + t82) * t91 * t175 +
        t90 * (t34_tmp -
               t148 *
                   ((t5_tmp * t57_tmp * 0.140154 + t7_tmp * t66_tmp * 0.140154) -
                    t73 * t82 * 2.0) /
                   2.0);
    a_tmp = t18_tmp + t124_tmp * 0.2485;
    t120_tmp = (t16_tmp + t123_tmp * 0.2485) - 0.06;
    t182 = (t35_tmp + t83) * t94 * t175 +
           t93 * (t33_tmp -
                  t148 *
                      ((t182 * t57_tmp * 0.140154 + t6_tmp * t66_tmp * 0.140154) -
                       t75 * t83 * 2.0) /
                      2.0);
    t93 =
        (t36_tmp + t84) * t94 * t175 +
        t93 * (t34_tmp -
               t148 *
                   ((t5_tmp * t57_tmp * 0.140154 + t7_tmp * t66_tmp * 0.140154) -
                    t75 * t84 * 2.0) /
                   2.0);
    t94 = t18_tmp + t124_tmp * 0.2485;
    t148 = (t16_tmp + t123_tmp * 0.2485) - 0.06;
    t104 = (-t16_tmp - t123_tmp * 0.2485) + 0.06;
    t82 = t104 * t104;
    t175 = 1.0 / t104;
    t84 = t123_tmp * t143;
    t73 = t124_tmp * t143;
    t81 = leg->F * (1.0 / std::sqrt(a_tmp * a_tmp + t120_tmp * t120_tmp));
    t91 = t123_tmp * t131;
    t90 = t124_tmp * t131;
    t120_tmp = a_tmp * (1.0 / t82);
    t104 = leg->Tp * t82 * (1.0 / (a_tmp * a_tmp + t82));
    leg->T1 = t81 *
               (t94 * (t16_tmp - t84 * t182 * 0.497) * 2.0 -
                t148 * (t18_tmp - t73 * t182 * 0.497) * 2.0) /
               2.0 -
           t104 * (t175 * (t16_tmp - t91 * t180 * 0.497) -
                   t120_tmp * (t18_tmp - t90 * t180 * 0.497));
    leg->T2 = t81 * (t84 * t94 * t93 * 0.994 - t73 * t148 * t93 * 0.994) / 2.0 +
           t104 * (t175 * (0.0 - t91 * t181 * 0.497) +
                   t120_tmp * (t90 * t181 * 0.497));
}

void VMC::FN_solve(Leg_Model *leg)
{
    double P = 0;
    double cos_theta = 0;
    double sin_theta = 0;
    double F = 0;
    double Tp = 0;
    double L0 = 0;
    double dL0 = 0;
    double ddL0 = 0;
    double theta = 0;
    double dtheta = 0;
    double ddtheta = 0;
    double ddzw = 0;
    double ddzm = 0;
    double r, p;
    r = roll * pi / 180;
    p = pitch * pi / 180;
    theta = leg->theta;
    dtheta = leg->dTheta->now;
    ddtheta = leg->dTheta->d;
    F = leg->F;
    Tp = leg->Tp;
    L0 = leg->L0;
    dL0 = leg->dL0->now;
    ddL0 = leg->dL0->d;
    cos_theta = std::cos(theta);
    sin_theta = std::sin(theta);
    ddzm = -ddx * sin(p) + ddy * cos(p) * sin(r) + ddz * cos(r) * cos(p) - g;
    ddzw = ddzm - ddL0 * cos_theta + 2 * dL0 * dtheta * sin_theta + L0 * ddtheta * sin_theta + L0 * dtheta * dtheta * cos_theta;
    P = F * cos_theta + Tp * sin_theta / L0;
    leg->FN = P + m_wheel * g + m_wheel * ddzw;
    // cout << "F=" << F << ",FN=" << leg->FN << endl;
    if (leg->FN <= off_ground_F) // 支持力不够
    {
        if (!leg->isRobotOffGround) // 当前为落地状态
        {
            leg->counter_OffGround++;
        }
        else // 当前为离地状态
        {
            leg->counter_OffGround = 0;
        }
    }
    else // 支持力够
    {
        if (!leg->isRobotOffGround) // 当前为落地状态
        {
            leg->counter_OffGround = 0;
        }
        else // 当前为离地状态
        {
            leg->counter_OffGround--;
        }
    }
    if (leg->counter_OffGround > 3)
    {
        leg->isRobotOffGround = true;
        ROS_ERROR("robotoffground");
    }
    if (leg->counter_OffGround < -3)
    {
        leg->isRobotOffGround = false;
    }
}
